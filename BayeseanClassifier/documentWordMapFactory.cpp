/* This file is part of BayseanClassifier. It classifies documents into
    categories based on the classic Baysean classification algorithm.

    Copyright (C) 2016   Ezra Erb

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 3 as published
    by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    I'd appreciate a note if you find this program useful or make
    updates. Please contact me through LinkedIn (my profile also has
    a link to the code depository)
*/

/* This class defines a map representing a document as a bag of words.
    It gets generated by a factory that takes as input a file with
    the document */
#include <string>
#include <map>
#include <fstream>
#include <sstream>
#include <iostream>

#include "baseException.h"
#include "porterStemmer.h"
#include "stopwords.h"
#include "documentWordMapFactory.h"

using namespace std;

const string DocumentWordMapFactory::_letters("abcdefghijklmnopqrstuvwxyz");

// Return the total word count of the map
unsigned int DocumentWordMap::getTotalWordCount() const
{
    unsigned int result = 0;
    const_iterator index;
    for (index = begin(); index != end(); index++)
        result += index->second;
    return result;
}

// Return a atring containing all data in the map
// WARNING: Likely to be huge
string DocumentWordMap::allMapData() const
{
    ostringstream buffer;
    const_iterator index;
    for (index = begin(); index != end(); index++)
        buffer << index->first << ":" << index->second << " ";
    return buffer.str();
}

// Construct with the list of stopwords to use. Does not take ownership
DocumentWordMapFactory::DocumentWordMapFactory(const Stopwords& stopwords)
    : _stopwords(stopwords)
{}

// Convert the specified file into a document word map
void DocumentWordMapFactory::getWordMap(const string& fileName,
                                        DocumentWordMap& wordMap) const
{
    ifstream file;
    wordMap.clear();
    try {
        file.open(fileName.c_str());
        if (!file.is_open()) {
            stringstream errorMessage;
            errorMessage << "Error, could not open data file " << fileName;
            THROW_BASE_EXCEPTION(errorMessage.str().c_str());
        }

        string word;
        string wrapped;
        // Classic C method of doing case changes
        unsigned short caseFold = (short)'A' - (short)'a';

        while (file >> word) {
            string::iterator index;
            // Convert to lowercase. The classic C method of doing so
            for (index = word.begin(); index != word.end(); index++) {
                if ((*index >= 'A') && (*index <= 'Z'))
                    *index = (char)((short)*index - caseFold);
            }

            // If a word wrapped from the previous line, prepend it
            if (!wrapped.empty()) {
                wrapped.append(word);
                word.swap(wrapped);
                wrapped.clear();
            }

            /* If the last letter is a dash, it wrapped. Remove the dash and append
                to the next word */
            if (word[word.length() - 1] == '-') {
                word.erase(word.length() - 1);
                wrapped.swap(word);
            }
            else {
                /* Strip non-alpha chars at the start and end. Punctuation in
                    the middle gets kept. Note that this will strip out
                    numerics, which normally aren't high-frequency enough for
                    useful classifiation */
                size_t firstChar = word.find_first_of(_letters);
                if (firstChar != string::npos) {
                    size_t lastChar = word.find_last_of(_letters);
                    // If last two chars are apostophe-s, ignore them
                    if ((lastChar > 1) && (word[lastChar] == 's') &&
                        (word[lastChar - 1]) == '\'')
                        lastChar -= 2;
                    if (lastChar >= firstChar) {
                        if ((firstChar > 0) || (lastChar < word.length() - 1))
                            word = word.substr(firstChar, lastChar - firstChar + 1);

                        // Test the word against the stopword list. If not found, continue processing
                        if (!_stopwords.isStopword(word)) {
                            // Convert to stem
                            word = PorterStemmer::getStem(word);
                            wordMap.addWord(word);
                        } // Not a stopword
                    } // Wanted letters in word
                } // Found a letter in the word
                // else word has no letters, ignore
            } // Word did not wrap to the next line
        } // While words to read in the file
        file.close();
    }
    catch (...) {
        // Ensure file always released
        if (file.is_open())
            file.close();
        // Clear the partial results so always consistent
        wordMap.clear();
        throw;
    }
}
